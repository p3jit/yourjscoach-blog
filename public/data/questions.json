[
  {
    "id": 14,
    "documentId": "exzg9w5c3rqrpklvv1oompik",
    "problemTitle": "Maximum Subarray",
    "mdContent": "<NormalText>Given an array of integers, return the maximum subarray sum using Kadane's algorithm.</NormalText><br/><Example input='\"[-2,1,-3,4,-1,2,1,-5,4]\"' output='6' name='example1' explanation='The contiguous subarray [4,-1,2,1] has the largest sum = 6.'/><br/>",
    "difficulty": 3,
    "editorValueCode": "//Complete the following function\nfunction maxSubArray(nums) {\n  // Your code here\n}",
    "editorValueTests": "describe('maxSubArray', () => {\n  it('should return the maximum subarray sum for a given array', () => {\n    expect(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])).toBe(6);\n  });\n  it('should handle an empty array', () => {\n    expect(maxSubArray([])).toBe(-Infinity);\n  });\n  it('should handle an array with a single element', () => {\n    expect(maxSubArray([1])).toBe(1);\n  });\n  it('should handle an array with all negative numbers', () => {\n    expect(maxSubArray([-1,-2,-3,-4])).toBe(-1);\n  });\n  it('should handle an array with all positive numbers', () => {\n    expect(maxSubArray([1,2,3,4])).toBe(10);\n  });\n});",
    "functionName": "maxSubArray",
    "tags": ["array", "dynamic programming"],
    "askedIn": ["Amazon", "Microsoft"],
    "createdAt": "2025-06-12T19:53:09.222Z",
    "updatedAt": "2025-06-12T19:53:09.222Z",
    "publishedAt": "2025-06-12T19:53:09.226Z",
    "description": "Kadane's algorithm is a dynamic programming approach used to find the maximum sum of a contiguous subarray in an array of integers.",
    "category": "dsa",
    "solution": "function maxSubArray(nums) {\n  let max_current = nums[0];\n  let max_global = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    max_current = Math.max(nums[i], max_current + nums[i]);\n    if (max_current > max_global) {\n      max_global = max_current;\n    }\n  }\n  return max_global;\n}"
  },
  {
    "id": 16,
    "documentId": "nu2ztm7mrbikhu1qk7l8i0rz",
    "problemTitle": "Search in Rotated Sorted Array",
    "mdContent": "<NormalText>Given an array of integers and a target value, find the index of the target if it is in the array. If not, return -1.</NormalText><br/><Example input='\"[3,4,5,6,7,0,1,2]\", \"target=0\"' output='5' name='example1' explanation='The target 0 is at index 5.'/><br/>",
    "difficulty": 3,
    "editorValueCode": "//Complete the following function\nfunction search(nums, target) {\n  // Your code here\n}",
    "editorValueTests": "describe('search', () => {\n  it('should return the index of the target if it is in the array', () => {\n    expect(search([3,4,5,6,7,0,1,2], 0)).toBe(5);\n  });\n  it('should return -1 if the target is not in the array', () => {\n    expect(search([3,4,5,6,7,0,1,2], 3)).toBe(-1);\n  });\n  it('should handle an empty array', () => {\n    expect(search([], 1)).toBe(-1);\n  });\n  it('should handle an array with a single element', () => {\n    expect(search([1], 1)).toBe(0);\n  });\n  it('should handle an array with all elements equal to the target', () => {\n    expect(search([2,2,2,2], 2)).toBe(0);\n  });\n});",
    "functionName": "search",
    "tags": ["array", "binary search"],
    "askedIn": ["Google", "Apple"],
    "createdAt": "2025-06-12T19:53:21.672Z",
    "updatedAt": "2025-06-12T19:53:21.672Z",
    "publishedAt": "2025-06-12T19:53:21.680Z",
    "description": "This problem involves searching for a target value in a rotated sorted array. A rotated sorted array is one that has been rotated at some pivot point.",
    "category": "dsa",
    "solution": "function search(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}"
  },
  {
    "id": 18,
    "documentId": "q6vg2pjra88sdsuj0ontzhbl",
    "problemTitle": "Contains Duplicate II",
    "mdContent": "<NormalText>Given an array of integers and a value k, return true if there are two distinct indices i and j such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</NormalText><br/><Example input='\"[1,2,3,4,5], \"k=2\"' output='false' name='example1' explanation='No two distinct indices have an absolute difference of at most 2 that are equal.'/><br/>",
    "difficulty": 2,
    "editorValueCode": "//Complete the following function\nfunction containsNearbyDuplicate(nums, k) {\n  // Your code here\n}",
    "editorValueTests": "describe('containsNearbyDuplicate', () => {\n  it('should return true if there are two distinct indices with an absolute difference of at most k that are equal', () => {\n    expect(containsNearbyDuplicate([1,2,3,1], 3)).toBe(true);\n  });\n  it('should return false if there are no such indices', () => {\n    expect(containsNearbyDuplicate([1,0,1,1], 1)).toBe(false);\n  });\n  it('should handle an empty array', () => {\n    expect(containsNearbyDuplicate([], 1)).toBe(false);\n  });\n  it('should handle an array with a single element', () => {\n    expect(containsNearbyDuplicate([1], 1)).toBe(false);\n  });\n  it('should return true if k is greater than the length of the array', () => {\n    expect(containsNearbyDuplicate([1,2,3,4], 5)).toBe(false);\n  });\n});",
    "functionName": "containsNearbyDuplicate",
    "tags": ["array", "hash table"],
    "askedIn": ["Microsoft", "Facebook"],
    "createdAt": "2025-06-12T19:53:34.441Z",
    "updatedAt": "2025-06-12T19:53:34.441Z",
    "publishedAt": "2025-06-12T19:53:34.446Z",
    "description": "This problem checks for duplicate elements within a certain distance 'k' in an array. It uses a hash table (or dictionary) to keep track of the indices of elements.",
    "category": "dsa",
    "solution": "function containsNearbyDuplicate(nums, k) {\n  let map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    if (map.has(nums[i])) {\n      if (i - map.get(nums[i]) <= k) {\n        return true;\n      }\n    }\n    map.set(nums[i], i);\n  }\n  return false;\n}"
  }
]
